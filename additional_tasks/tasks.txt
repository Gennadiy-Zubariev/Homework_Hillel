'''Additional task 20
# Напишіть програму, яка запитує у користувача суму у євро і потім виводить:
# мінімальну кількисть купюр та мінімальну кількість монет для того, щоб
# отримати цю суму у євро. Зверніть увагу на те, що банкноти євро мають
# номінали: 5, 10, 20, 50, 100, 200 та 500 евро. А монети: 1 та 2 євро,
# 1, 2, 5, 10, 20 та 50 євроцентів.
# Крім того треба надрукувати кількість кожного номіналу котрий
# використовується для отримання даної суми.
# * Бажано, щоб суму можна було вводити як через крапку так і через кому.

# Приклад: Введіть суму: 347,78
# Кількість банкнот: 5
# Кількість монет: 7
# Склад суми:
# 1 x 200
# 1 x 100
# 2 x 20
# 1 x 5
# 2 x 1
# 1 x 0.5
# 1 x 0.2
# 1 x 0.05
# 1 x 0.02
# 1 x 0.01
'''

# from collections import defaultdict
#
# euro = float(input('Enter num euro: ').replace(',', '.'))
#
# l_nom =[500, 200, 100, 50, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.02, 0.01]
# d = defaultdict(lambda: 0)
#
# for i in l_nom:
#     count, euro = divmod(euro, i)
#     d[i] = int(count)
#     euro = round(euro, 2)
#
# bank = {k: v for k, v in d.items() if k in [500, 200, 100, 50, 20, 10, 5] and v > 0}
# mon = {k: v for k, v in d.items() if k in [2, 1, 0.5, 0.2, 0.1, 0.05, 0.02, 0.01] and v > 0}
# print(f'Кількість банкнот: {sum(bank.values())}')
# print(f'Кількість монет: {sum(mon.values())}')
# for k, v, in bank.items():
#     print(f'Номінал банкноти {k} - {v:.0f} шт.')
# for k, v, in mon.items():
#     print(f'Номінал монети {k} - {v:.0f} шт.')

'''Additional task 21
# Існує функція coffee(), яка варить каву і якщо її викликати, то вона друкує
# "кава".
# Написати декоратор та декорувати цю функцію так, щоб можна було варити каву
# з цукром, молоком або тим та іншим водночас. Також можна заварити подвійну
# каву, або каву з подвійним молоком, чи подвійним цукром. Якщо виклакити
# задекоровану функцію без аргументів, то вона зварить звичайну каву, так
# наче функція не декорована. При чому ніяких змін до самої функції coffee()
# вносити не можна.
'''

# def decorator(func):
#     def wrapper(*args, **kwargs):
#         supplements = []
#         if kwargs.get('milk') == 1:
#             supplements.append('з молоком')
#         if kwargs.get('milk') == 2:
#             supplements.append('з подвійним молоком')
#         if kwargs.get('sugar') == 1:
#             if kwargs.get('milk', 0):
#                 supplements.append('та цукром')
#             else:
#                 supplements.append('з цукром')
#         if kwargs.get('sugar') == 2:
#             if kwargs.get('milk', 0):
#                 supplements.append('та подвійним цукром')
#             else:
#                 supplements.append('з подвійним цукром')
#         if kwargs.get('double'):
#                 supplements.append('подвійна')
#
#         if supplements:
#             print(f"{' '.join(supplements)}", end=' ')
#         func()
#     return wrapper
# @decorator
# def coffe():
#     print('кава')
#
# a = coffe(milk=2, sugar=1, double=True)


'''Additional task 22
# Напишіть програму, яка запитує у користувача число N і виводить на
# Екран таблицю множення від 1 до N. Використовуйте вкладений цикл for для
# створення таблиці множення. Виведіть результат на екран за допомогою print.
#
# Приклад:
# Введіть число N: 5
# Таблиця множення:
# 1  2  3  4  5
# 2  4  6  8 10
# 3  6  9 12 15
# 4  8 12 16 20
# 5 10 15 20 25
'''

# n = int(input('Enter n: '))
# for i in range(1, n + 1):
#     print()
#     for t in range(1, n + 1):
#         print(f'{i * t:^3}', end=' ')


'''Additional task 23
# Напишіть програму, яка приймає список чисел і повертає суму, мінімальне та
# максимальне значення зі списку. Використовуйте функцію для обробки списку
# чисел та повернення трьох значень. Виведіть результат на eкран за допомогою
# команди print.
#
# Приклад:
# Введіть числа через кому та пробіл: 3, 7, 2, 9, 1, 5
# Сума чисел: 27
# Мінімальне значення: 1
# Максимальне значення: 9
'''

# def process():
#     lst = input('Enter list(ex. (3, 7, 2, 9, 1, 5)): ')
#     r = [int(i) for i in lst.split(',')]
#     return sum(r), min(r), max(r)
#
# s, minimum, maximum = process()
# print(f'Сума чисел: {s}\nМінімальне значення: {minimum}\nМаксимальне значення: {maximum}')

'''Additional task 24
# Напишіть програму, яка приймає рядок користувача та розбиває його на окремі
# слова. Потім програма має об'єднати слова у зворотному порядку. При цьому
# перше слово у зміненому порядку друкується з великої літери, а останнє котре
# було на першому місці і було з великої літери у зворотньому порядку
# друкується з маленької літери
#
# Приклад:
# Введіть строку: Програмування це цікаво та корисно
# Перевернута строка: Корисно та цікаво це програмування
'''
# input_text = input('Enter text: ')
#
# rev_text = input_text.split()[::-1]
#
# rev_text[0] = rev_text[0].capitalize()
# rev_text[-1] = rev_text[-1].lower()
#
# result_text = ' '.join(rev_text)
#
# print(result_text)

'''Additional task 25 !!!!!!!!!!!!!!!!
# Напишіть програму, яка приймає рядок від користувача та розбиває його на окремі
# слова. Потім програма має створити новий кортеж, що містить довжину кожного
# слова у вихідному рядку. Використовуйте методи рядків та кортежів для обробки даних.
#
# Приклад:
# Введіть речення: Програмування це цікаво та корисно
# Довжини слів у реченні: (13, 2, 6, 2, 7)
'''

# def word_count(st):
#     a = st[:]
#     punctuation = ".,;:!?—()[]{}\"'…«»`~@#$%^&*-_=+|\\/<>"
#     for letter in a:
#         if letter in punctuation:
#             a = a.replace(letter, '')
#     print(a)
#     return tuple(len(word) for word in a.split())
#
# t = word_count('Програмування, це../ цікаво та корис!но')
# print(t)


'''Additional task 26
# Напишіть програму, яка приймає список чисел від користувача та сортує
# його в порядку зменшення, використовуючи метод sort() і параметр
# reverse = True. Виведіть відсортований список на екрані.
#
# Приклад:
# Введіть список чисел, розділених пробілами: 5 2 8 1 3
# Відсортований список чисел: [8, 5, 3, 2, 1]
'''

# def digit_sort():
#     s = input('Enter digit ex. 5 2 8 1 3: ')
#     p = s.split()
#     p.sort(reverse=True)
#     return p
#
# f = digit_sort()
# print(f)

'''Additional task 27
# Напишіть програму, яка за числом n від 1 до 9 виводить на екран n
# пінгвінів. Зображення одного пінгвіна має розмір 5х9 символів.
# Вхідні дані:
# Вводиться натуральне число.
# Вихідні дані:
# Виводиться введена кількість пінгвінів у рядок.
# Примітка:
# Врахуйте, що виведення даних на екран робиться рядковим, а не попінгвінним.
#
# У деяких мовах програмування символ зворотного слеша “\” у текстових
# рядках має спеціальне значення. Щоб включити до текстового рядка
# такий символ, його потрібно повторити двічі. Наприклад, для виведення на екран
# одного такого символу можна використовувати такий код: print("\\").
#    _~_
#   (o o)
#  /  V  \
# /(  _  )\
#   ^^ ^^
#
# Приклад:
# Введить кількість пінгвінів: 3
'''

# pingv = {
#     1: '   _~_   ',
#     2: '  (o o)  ',
#     3: ' /  V  \\ ',
#     4: '/(  _  )\\',
#     5: '  ^^ ^^  '
#     }
#
# variable = int(input('Enter num 0-9: '))
# for v in pingv.values():
#     print()
#     for i in range(variable):
#         print(v, end=' ')

'''Additional task 28
# Напишіть генератор, який генеруватиме нескінченну послідовність Фібоначчі.
# Щоразу, коли генератор викликається, він повинен повертати таку кількість
# послідовності. Напишіть програму, яка використовуватиме цей генератор для
# виведення перших N чисел Фібоначчі.
# Приклад висновку:
# Введіть кількість чисел Фібоначчі: 10
# Перші 10 чисел Фібоначчі:
# 0
# 1
# 1
# 2
# 3
# 5
# 8
# 13
# 21
# 34
'''

# def fibo():
#     a = 0
#     b = 1
#     while True:
#         yield a
#         a, b = b, a + b
#
# n = int(input('Введіть кількість чисел Фібоначчі: '))
# print(f'Перші {n} чисел Фібоначчі: ')
# d = fibo()
# for _ in range(n):
#     print(next(d))

'''Additional task 29
# Даний список цілих чисел довжини 1 і більше. Написати функцію, яка повертає список
# довжини 2, що складається з першого та останнього елемента вхідного списку.
# [1, 2, 3] -> [1, 3], [7, 4, 6, 2] -> [7, 2], [5] -> [5, 5]
'''

# def first_last(lst):
#     return list[lst[0], lst[-1]]
#
# a = first_last([5])
# print(a)

'''Additional task 30
# Написати функцію, яка повертає true, якщо у списку йде поспіль два
# рази задане число.
# Якщо задане число 2, то [1, 2, 2] -> true, [2, 1, 2] -> false
'''

# def find_digit(x, lst):
#     for i in range(len(lst) - 1):
#         if lst[i] == lst[i + 1] == x:
#             return True
#     return False
#
#
# a = find_digit(2, [1, 2, 2, 3, 5, 4, 5, 5, 6, 8])
# print(a)

'''Additional task 31
# Напишіть програму, яка використовує рекурсію для обчислення суми цифр
# Числа. Створіть функцію sum_digits, яка приймає один аргумент – число,
# для якого потрібно обчислити суму цифр. Використовуйте умову виходу з
# рекурсії, коли число складається з однієї цифри. Виведіть результат на екран.
#
# Приклад:
# Введіть число: 12345
# Сума цифр числа 12345 дорівнює 15
'''

# def sum_digits(dig):
#
#     if dig <= 0:
#         return 0
#     return  dig % 10 + sum_digits(dig // 10)
#
# d = int(input('Enter digit: '))
# print(f'Sum digits {d} = {sum_digits(d)}')


'''Additional task 32
# Напишіть програму, яка приймає список слов і повертає список, містить тільки
# анаграми. Анаграми - це слова, складені з тих самих букв, але у різному
# порядку. Створіть функцію anagrams, яка приймає список слів як аргумент
# та повертає список анаграм. Використовуйте безліч і сортування букв у слові
# для перевірки на анаграму. Виведіть результат на екран.
#
# Приклад переданого списку слів:
# ['cat', 'dog', 'tac', 'god', 'act']
#
# Приклад висновку:
# Анаграми: ['dog', 'god'], ['cat', 'tac', 'act']
'''

# def anagramm(lst):
#     from collections import defaultdict
#     an = defaultdict(list)
#     for i in lst:
#         key = ''.join(sorted(i.lower()))
#         an[key].append(i)
#     for v in an.values():
#         print(v)
#
# anagramm(['cat', 'dog', 'tac', 'god', 'act'])


'''Additional task 33
# Напишіть функцію is_subset, яка приймає дві множини set1 і set2 і
# перевіряє, чи є set1 підмножиною set2. Функція має повертати
# True, якщо всі елементи set1 містяться в set2, і False в іншому
# Випадок. Функція має бути реалізована без використання вбудованих методів
# issubset або <=.
#
# Приклад множин
# {1, 2, 3}
# {1, 2, 3, 4, 5}
#
# Приклад висновку:
# True
'''

# def is_subset(set1, set2):
#     upd_set = set2.union(set1)
#     if len(upd_set) == len(set2):
#         return True
#     return False
#
# print(is_subset({1, 2, 3}, {1, 2, 3, 4, 5}))

'''Additional task 34
# Напишіть функцію merge_dicts, яка приймає довільну кількість словників
# як аргументи і повертає новий словник, що об'єднує все вхідні словники.
# Якщо ключі повторюються, значення мають бути об'єднані в перелік.
# Функція повинна використовувати аргумент *args або **kwargs для
# прийняття довільного числа словників.
#
# Приклад введення:
# {'a': 1, 'b': 2}
# {'b': 3, 'c': 4}
# {'c': 5, 'd': 6}
#
# Приклад висновку:
# {'a': [1], 'b': [2, 3], 'c': [4, 5], 'd': [6]}
'''

# def merde_dicts(*args):
#     from itertools import chain
#     new_dict = {}
#     for d in args:
#         for k, v in d.items():
#             if k in new_dict:
#                 new_dict[k].append(v)
#             new_dict.setdefault(k, [v])
#     print(new_dict)
#
# merde_dicts({'a': 1, 'b': 2}, {'b': 3, 'c': 4}, {'c': 5, 'd': 6})


'''Additional task 35
# Напишіть програму, яка приймає рядок від користувача та підраховує
# кількість унікальних символів у цьому рядку. Створіть функцію
# count_unique_chars, яка приймає рядок та повертає кількість
# Унікальні символи. Виведіть результат на екран.
#
# Приклад:
# Введіть рядок: hello
# Кількість унікальних символів: 4
'''

# line = input('Enter string: ')
#
# def count_unique_chars(l):
#     d = {}
#     for i in l:
#         d.setdefault(i, [])
#     print(len(d))
#
# count_unique_chars(line)
#
#
#
# def count_unique_chars(text):
#     return len(set(text))
#
# # Отримання рядка від користувача
# user_input = input("Введіть рядок: ")
#
# # Підрахунок і вивід результату
# print("Кількість унікальних символів:", count_unique_chars(user_input))

'''Additional task 36
# Напишіть програму, яка створює словник, що містить інформацію про
# студенти та їх оцінки. Ключами словника є імена студентів, а
# значеннями – списки оцінок. Створіть функцію calculate_average_grade,
# яка приймає словник з оцінками студентів та обчислює середній бал
# для кожного студента. Функція повинна повертати новий словник, у
# якому ключами є імена студентів, а значеннями - їх середній бал.
# Виведіть результат на екран.
#
# Приклад словника з оцінками
# grades = {
# 'Alice': [85, 90, 92],
# 'Bob': [78, 80, 84],
# 'Carol': [92, 88, 95]
# }
#
# Приклад висновку:
# {'Alice': 89.0, 'Bob': 80.67, 'Carol': 91.67}
'''

# grades = {
# 'Alice': [85, 90, 92],
# 'Bob': [78, 80, 84],
# 'Carol': [92, 88, 95]
# }
#
# def calculate_average_grade(dictionary):
#     d = {}
#     for name, marks  in dictionary.items():
#         d[name] = round(sum(marks)/len(marks), 2)
#     return d
#
# print(calculate_average_grade(grades))


'''Additional task 37
# Дано натуральне число N. Написати функцію power_of_2(N), яка друкує
# слово YES, якщо число N є точним ступенем двійки, або слово NO в
# інакше. Користуємося рекурсією, а операцією зведення на ступінь не
# користуємося.
#
# Приклад:
# power_of_2(8) поверне YES
# poser_of_2(3) поверне NO.
'''

# def power_of_2(n):
#     if n == 1:
#         return f'Yes'
#     elif n < 1 or n % 2 != 0:
#         return 'No'
#     else:
#         return power_of_2(n / 2)
#
# power_of_2(8) #поверне YES
# power_of_2(3) #поверне NO.

'''Additional task 38
# Дана послідовність слів. Написати функцію, яка повертає послідовність
# слів з вихідної послідовності відсортованих по алфавіту, довжина
# яких більше трьох букв і до кожного слова застосовано метод title().
#
# Приклад: ["HellO", "WORLD", "names", "Is", "Sam", "NO", "apple"]
# Результат: ['Apple', 'Hello', 'Names', 'World']
'''

# def sort_list(l):
#     t_l = [i.title() for i in l if len(i) > 3]
#     return sorted(t_l)
#
# sort_list(["HellO", "WORLD", "names", "Is", "Sam", "NO", "apple"])


'''Additional task 39
# Напишіть функцію find_longest_word, яка прийматиме список слів і
# повертати найдовше слово зі списку.
# Анотуйте типи аргументів і значення функції, що повертається.
#
# Приклад виклику функції та очікуваного виводу:
# words = ["apple", "banana", "cherry", "dragonfruit"]
# result = find_longest_word(words)
# print(result)
# Очікуваний висновок: "dragonfruit"
'''

# def find_longest_word(l):
#     res = sorted(l, key=len)
#     return res[-1]
#
# words = ["apple", "banana", "cherry", "dragonfruit"]
# result = find_longest_word(words)
# print(result)


'''Additional task 40
# Напишіть функцію, яка приймає на вхід список чисел та повертає суму
# квадратів тільки парних чисел зі списку, використовуючи функціональні
# підходи (наприклад, map, filter та reduce).
#
# Приклад:
# Введіть числа: 4, 6, 3, 4, 2, 3, 9, 0, 7
# Результат: 72
'''

# def summ_squares(l):
#     k = l.split(',')
#     res = sum(map(lambda x: int(x) ** 2, filter(lambda x: int(x) % 2 == 0, k)))
#     print(res)
#
#
# inp = input('Enter digits: ')
#
# summ_squares(inp)


'''Additional task 41
# Напишіть функцію, яка приймає на вхід список функцій та значення, а потім
# застосовує композицію цих функцій значення, повертаючи кінцевий результат.
#
# Приклад:
# add_one = lambda x: x + 1
# double = lambda x: x * 2
# subtract_three = lambda x: x - 3
#
# functions = [add_one, double, subtract_three]
# compose_functions(functions, 5) має вивести 9
'''

# def compose_functions(functions, a):
#
#     for func in functions:
#         a = func(a)
#     return a
#
#
# add_one = lambda x: x + 1
# double = lambda x: x * 2
# subtract_three = lambda x: x - 3
#
# functions = [add_one, double, subtract_three]
# res = compose_functions(functions, 5)
# print(res)


'''Additional task 42
# Дана послідовність слів. Написати функцію, яка повертає послідовність
# слів, в якій у словах довжини 3 всі літери великі, а всі слова, що
# починаються на "q" або "f" виключені. Використовувати ланцюжки.
# Приклад: ["The", "quick", "brown", "fox"] -> ["THE", "brown"]
'''

# def words(lst):
#     return list(
#         map(lambda i: i.upper() if len(i)== 3 else i,
#                filter(lambda j: not j.startswith(('q', 'f')), lst)))
# a = ["The", "quick", "brown", "fox"]
# r = words(a)
# print(list(r))


'''Additional task 43
# Створіть клас BankAccount для надання банківського рахунку. Клас повинен
# мати атрибути account_number (номер рахунку) та balance (баланс), а також
# методи deposit() для внесення грошей на рахунок і withdraw() для зняття
# грошей з рахунку. Потім створіть екземпляр класу BankAccount, внесіть на
# рахунок деяку суму і зніміть частину грошей. Виведіть баланс, що залишився.
# Не забудьте передбачити варіант, при якому при знятті баланс може стати
# меншим за нуль. У цьому випадку йти в мінус не будемо, замість чого
# повертатимемо повідомлення "Недостатньо коштів на рахунку".
'''

# class BankAccount:
#     def __init__(self, account_number, balance=0):
#         self.account_number = account_number
#         self.balance = balance
#
#     def deposit(self, dep):
#         self.balance += dep
#
#     def withdraw(self, wit):
#         if self.balance > wit:
#             self.balance -= wit
#         else:
#             print("Недостатньо коштів на рахунку")
#
#     def __str__(self):
#         return f'account number-{self.account_number}\nbalance-{self.balance}'
#
# a = BankAccount('0000_0000_0000_0001', 999)
# a.deposit(1300)
# a.withdraw(5000)

'''Additional task 44
# Реалізувати клас Counter, який представляє лічильник. Клас повинен
# підтримувати такі операції:
# - Збільшення значення лічильника на задане число (оператор +=)
# - Зменшення значення лічильника на задане число (оператор -=)
# - Перетворення лічильника на рядок (метод __str__)
# - Отримання поточного значення лічильника (метод __int__)
#
# Приклад використання:
# counter = Counter(5)
# counter += 3
# print(counter) # Результат: "Counter: 8"
# counter -= 2
# print(int(counter)) # Результат: 6
'''

# class Counter:
#     def __init__(self, count):
#         self.count = count
#
#     def __iadd__(self, other):
#         self.count += other
#         return self
#
#     def __isub__(self, other):
#         self.count -= other
#         return self
#
#     def __str__(self):
#         return f'{self.count}'
#
#     def __int__(self):
#         return  self.count
#
# counter = Counter(5)
# counter += 3
# print(counter) # Результат: "Counter: 8"
# counter -= 2
# print(int(counter)) # Результат: 6


'''Additional task 45
# Створити програму-калькулятор у вигляді класу та кілька методів, як мінімум
# додавання, віднімання, ділення, множення, зведення в ступінь та вилучення
# квадратного кореня. Обернути кожен метод у блок try/except і зробити обробку
# кількох винятків, як мінімум ділення на 0. Створити свій виняток, наприклад,
# зведення в негативний ступінь.
'''

class NegativePower(Exception):
    pass


# class Calc:
#
#     # def __init__(self, a, b):
#     #     self.a = a
#     #     self.b = b
#
#     def add(self, a, b):
#         try:
#             return a + b
#         except TypeError as err:
#             print(err)
#
#     def sub(self, a, b):
#         try:
#             return a - b
#         except TypeError as err:
#             print(err)
#
#     def mult(self, a, b):
#         try:
#             return a * b
#         except TypeError as err:
#             print(err)
#
#     def div(self, a, b):
#         try:
#             return a / b
#         except ZeroDivisionError as err:
#             print(err)
#         except TypeError as err:
#             print(err)
#
#     def pow(self, a, pow=1):
#         try:
#             if pow < 0:
#                 raise NegativePower("Negative exponents are not allowed")
#             return a ** pow()
#         except NegativePower as err:
#             print(err)
#         except TypeError as err:
#             print(err)
#
#     def sqrt(self,a):
#         try:
#             if a < 0:
#                 raise ValueError("Cannot take square root of a negative number")
#             return x ** 0.5
#         except ValueError as err:
#             print(err)
#         except TypeError as err:
#             print(err)
#
#
# calc = Calc()
# print(calc.add(5, 3))         # 8
# print(calc.div(10, 0))     # Error: Cannot divide by zero
# print(calc.pow(2, -3))      # Error: Negative exponents are not allowed
# print(calc.sqrt(-4))


'''Additional task 46
# Даний список, що складається з даних різного типу.
# Повернути новий список, де за допомогою функції map() кожен елемент типу
# int початкового списку приведений до типу str, елементи решти всіх типів
# передаються в новий список без зміни їх типу.
# У якості вхідної функції в map використовувати lambda-функцію.
'''
#
# mixed_list = [
#     42,                      # int
#     3.14,                    # float
#     "Hello, world!",         # str
#     True,                    # bool
#     None,                    # NoneType
#     [1, 2, 3],               # list
#     {"name": "Alice"},       # dict
#     (4, 5),                  # tuple
#     {1, 2, 3},               # set
#     lambda x: x + 1          # function
# ]
#
# new1 = []
# new2 = []
# res = list(map(lambda i: new2.append(str(i)) if isinstance(i, int)
#             and not isinstance(i, bool) else new1.append(i), mixed_list))
# print(new1)
# print(new2)

'''Additional task 47
# Написати програму яка складається з вічного циклу, що очікує введення числа
# або одне із значень: "вихід", "exit", "quit", "e" або "q" у будь-якому
# регістрі. При введенні одного з цих значень відбувається вихід із вічного
# циклу. При будь-якому іншому введенні викликається окрема функція, яка вміє
# розпізнавати введені числа. Сама функція нічого не роздруковує, вона
# повертає рядок типу: "Ви ввели негативне дробове число: -6.7" або "Ви ввели
# не коректне число: Erdf"
# Потім у циклі виводиться це повідомлення і цикл починається знову чекаючи
# наступного введення. Функція на вхід приймає рядок із введення з вічного
# циклу. Аналізує її виключно методом .isdigit() та іншими методами рядків,
# без доп.бібліотек і переводить рядок у число, якщо це можливо.
# Функція вміє розпізнавати негативні числа та десяткові дроби, а також
# розпізнає десяткові дроби як з точкою, так і з комою.
# Функція повертає рядок в якому описується яке число введено - негативне або
# позитивно, ціле або дробове і виводить його або повідомляє, що введено не
# коректне число.
#
# *Додатково: правильно розпізнається десятковий дріб без першого нуля.
# Крім того функція вміє розпознавати нуль.
#
# Приклади:
# -6,7    → Ви ввели від'ємне дробове число: -6.7
# 5       → Ви ввели позитивне ціле число: 5
# 5.4r    → Ви ввели неправильне число: 5.4r
# -.777   → Ви ввели від'ємне дробове число: -0.777
# ,45     → Ви ввели позитивне дробове число: 0.45
# 0       → Ви ввели нуль
# 0,00    → Ви ввели нуль
# -0.45.6 → Ви ввели не правильне число: -0.45.6
# -5-6    → Ви ввели не правильне число: -5-6
# .-777   → Ви ввели не правильне число: .-777
'''

#
# def digit(x):
#     digit = x.replace(',', '.').strip()
#     try:
#         float(digit)
#     except ValueError:
#         return f'Ви ввели неправильне число: {x}'
#
#     def pos_neg():
#         if digit.startswith('-'):
#             return f"від'ємне"
#         else:
#             return f'позитивне'
#
#     def point():
#         if '.' in digit:
#             return f'дробове'
#         else:
#             return f'ціле'
#
#     def fl_int():
#         return int(digit) if float(digit).is_integer() else float(digit)
#
#     if float(digit) == 0:
#         return f'Ви ввели нуль'
#     else:
#         return f'Ви ввели {pos_neg()} {point()} число {fl_int()}'
# ex = ["вихід", "exit", "quit", "e", "q"]
# while True:
#     num = input('Enter num or "вихід", "exit", "quit", "e" або "q" to exit')
#     if num.lower() in ex:
#         break
#     else:
#         print(digit(num))


'''Additional task 48
# Створіть власний клас String на основі стандартного класу str.
# В ньому необхідно:
#      • Розширити стандартний метод, відповідальний за додавання
#      • Написати відсутній у класі str метод відповідальний за віднімання
#
# Принцип роботи в новому класі String: об'єкти типу String можна додавати як
# між собою, так і з будь-яким іншим типом, який може бути приведений до типу
# рядка. "Під капотом", обидва операнди приводиться до типу рядків та потім
# відбувається конкаткатенація. Результатом додавання буде новий об'єкт класу
# String. Приклади виконання:
#
# String('New') + String(890)    ->    'New890'
# String(1234) + 5678            ->    '12345678'
# String('New') + 'castle'       ->    'Newcastle'
# String('New') + 77             ->    'New77'
# String('New') + True           ->    'NewTrue'
# String('New') + ['s', ' ', 23] ->    "New['s', ' ', 23]"
# String('New') + None           ->    'NewNone'
#
# Принцип віднімання в новому класі String: з об'єкту типу String ви можете
# відняти значення будь-якого іншого типу, яке можна привести до типу рядка.
# "Під капотом", обидва операнди приводяться до типу str, а потім з першого
# операнду видаляється перше входження значення другоо операнду, якщо такий
# має місце. Результатом віднімання стане новий об'єкт класу String. Якщо в
# першому операнді немає значення другого операнду, то результатом віднімання
# стане перший операнд без змін. Приклади виконання:
#
# String('New bala7nce') - 7               ->    'New balance'
# String('New balance') - 'bal'            ->    'New ance'
# String('New balance') - 'Bal'            ->    'New balance'
# String('pineapple apple pine') - 'apple' ->    'pine apple pine'
# String('New balance') - 'apple'          ->    'New balance'
# String('NoneType') - None                ->    'Type'
# String(55678345672) - 7                  ->    '5568345672'
#
# *Важливо! Результатом додавання або віднімання завжди буде об'єкт типу String.
'''
#
#
# class String(str):
#
#     def __init__(self, obj):
#         self.obj = obj
#
#     def __add__(self, other):
#         try:
#             return  String(str(self.obj) + str(other.obj))
#         except ValueError as err:
#             print(err)
#
#     def __sub__(self, other):
#         a = str(self.obj)
#         b = str(other)
#         if b in a:
#             res = a.replace(b, '', 1)
#             return String(res)
#         else:
#             return self.obj
#
#
#
# print(String('New') + String(890))    #->    'New890'
# print(String('New bala7nce') - 7)               #->    'New balance'
# print(String('New balance') - 'bal')            #->    'New ance'
# print(String('New balance') - 'Bal')            #->    'New balance'
# print(String('pineapple apple pine') - 'apple') #->    'pine apple pine'
# print(String('New balance') - 'apple')          #->    'New balance'
# print(String('NoneType') - None)                #->    'Type'
# print(String(55678345672) - 7)                  #->    '5568345672'

'''Additional task 49'''
# class Car:
#     fuel_tipes = ['бензин', 'дизель', 'електрика', 'гібрид']
#     colors = []
#     number_of_cars = 1
#
#     def __init__(self, model, year, fuel_tipe, color):
#         self.model = model
#         self.year = year
#         self.color = color
#         self.fuel_tipe = self.is_valid_fuel_type(fuel_tipe)
#         self.number = Car.number_of_cars
#         Car.number_of_cars += 1
#         if not color in Car.colors:
#             Car.colors.append(color)
#
#     def __str__(self):
#         return f'{self.model} {self.year} {self.fuel_tipe} {self.color}'
#
#     @property
#     def numbers(self):
#         return f'{self.number} from {Car.number_of_cars - 1}'
#
#     @staticmethod
#     def is_valid_fuel_type(fuel_tipe):
#         return fuel_tipe if fuel_tipe in Car.fuel_tipes else Car.fuel_tipes[0]
#     @classmethod
#     def get_used_colors(cls):
#         return f'we used {len(Car.colors)} colors'
#
#     @classmethod
#     def get_number_of_cars(cls):
#         return f'We to produce {Car.number_of_cars - 1} cars'
#
#
# car_1 = Car('Zaz', 1979, 'дизель', 'black')
# car_2 = Car('BMW', 2000, 'бензин', 'red')
# car_3 = Car('VOLVO', 2012, 'електрикаcccc', 'black')
# car_4 = Car('Mersedes', 2012, 'гібрид', 'black')
# print('COLORS:', Car.get_used_colors())
# print('NUMBER_OF_CARS:', Car.get_number_of_cars())
# for item in (car_1, car_2, car_3, car_4):
#     print('item:', item)
#     print('numbers:', item.numbers)

'''Additional task 50'''
# import requests
# import json
#
# def get_weather(city_name, api_key='227f19477ba9ffb549c0681602ca7c51'):
#     base_url = "https://api.openweathermap.org/data/2.5/weather"
#     params = {
#         'q': city_name,
#         'appid': api_key,
#         'units': 'metric',  # температура в Цельсіях
#         'lang': 'ua'        # українська мова
#     }
#
#     response = requests.get(base_url, params=params)
#
#     if response.status_code == 200:
#         data = response.json()
#         temp = data['main']['temp']
#         weather_desc = data['weather'][0]['description']
#         humidity = data['main']['humidity']
#         wind_speed = data['wind']['speed']
#         print(f"🌤 Погода в місті {city_name}:")
#         print(f"Температура: {temp}°C")
#         print(f"Опис: {weather_desc}")
#         print(f"Вологість: {humidity}%")
#         print(f"Швидкість вітру: {wind_speed} м/с")
#     else:
#         print(f"❌ Не вдалося отримати дані. Код помилки: {response.status_code}")
#
# # ==== Використання ====
# # API_KEY = "227f19477ba9ffb549c0681602ca7c51"  # <-- встав сюди свій ключ
# city = input("Введіть назву міста: ")
# get_weather(city)






























